
celsius = 5


//////////////////// VARIABLES /////////////////////



tstop = 20000
nb = 2
nc = 4


FREQ = 25		 	// Stimulation frequency in Hz
NPULSES = 6			// Number of pulses for stimulation

NAV = 0.014 			// Na channel density
KV = 0.004			// K channel density



PUMP = 1
PUMPDENSITY = .001

/////////////////   MORPHOLOGY ///////////////////////


create a, b[nb], c[nc]

// Main axon
a {nseg=100 L=10000 diam = 20}      // peripherial axon

// Primary branch
for i=0, nb-1 b[i]{

  nseg = 100
  L = 12000
  diam = 10
  connect b[i](0), a(1)

}

// Secondary branch
for j=0, nc-1 c[j]{
  
  nseg = 100
  L = 5000
  diam = 5
  if (j <2){

    connect c[j](0), b[0](1)
  }
  if(j>=2){

    connect c[j](0), b[1](1)
  }
}



objref DRG   					// create new object called DRG
DRG = new SectionList()				// Define DRG as a list of sections

a DRG.append()				// DRG sections: tjunction, stem, and soma   
for i=0,1 b[i]{
  
  DRG.append() 
}
for i=0,3 c[i]{
  
  DRG.append()  
} 

/////////////////// INITIALIZATION /////////////////


///// GENERAL INITIALIZATION /////////



proc init(){				// INITIALIZATION FUNCTION



  forall {

       v=-60				// VREST FOR ALL COMPARTMENTS

       finitialize(v)			// reset all state variables
       fcurrent()     			// calculate all currents
       	
       e_pas = -65  //v + (ina + ik)/g_pas	// calculate leak equilibrium potential
  }


}			/// end of initialization




wopen("Fig5coutput2.dat")		    // Open file to write results


///////////////////////// STIMULATE PERIPHERAL AXON /////////////////////

access a	  	    // Work with main axon
objectvar stim			    // create object called stim
stim = new IClamp(0.1)		    // Define stim as a current clamp (IClamp) at position 0.2
stim.del = 5			    // Stimulus delay
stim.dur = tstop		    // Duration of the stimulus
stim.amp = 0          // Amplitude of the stimulus starts as zero.


// Changing the Q10 values

for q10gna = 0,3{
   
  for q10pump = 0,3{

    for q10nam = 0, 3{

      for q10nah = 0, 3{

        print q10gna, q10pump, q10nam, q10nah

        for i=1,1{

          new_diam = 10

          print "diameter ",new_diam
          for j=0,1 b[j]{diam = new_diam}


          // changing the temperature from 6 to 30 degree celsius at 8 degree increment
          for T=0,3{

            celsius= 6 + T * 8

            print "T ", celsius

            forall {        // for all compartments

              insert nahh
              gnabar_nahh = NAV
              q10_g_nahh = q10gna *0.5 +2
              q10_m_nahh = q10nam *0.5 +2
              q10_h_nahh = q10nah *0.5 +2
              //mshift_nahh = -6   // NaV1.7/1.8 channelshift
              //hshift_nahh = 6    // NaV1.7/1.8 channelshift

              insert borgkdr      // insert delayed rectifier K channels
              gkdrbar_borgkdr = KV    // density of K channels
              insert ka
              gkabar_ka=0.008

              ek = -70        // K equilibrium potential

              insert pas      // insert leak channels 
              g_pas = 0.000125    // set Rm = 10000 ohms-cm2
              v = -60       // set Vrest

              Ra = 100      // intracellular resistance
            }

            forsec DRG{

              if (PUMP == 1) {

              insert nadifl

              insert pump
              pumpbar_pump = PUMPDENSITY
              q10_pump = q10pump*0.5 +2

              }
            }

            result = 3
            
            a_initial = 0
            b_initial = 0
            c_initial = 0

              if(result==3){

                init()            // initialize

                // initlize the starting concentration
                forsec DRG {

                if (PUMP == 1){

                  ko = 3.72
                  ki = 110
                  nao = 340
                  nai = 65
                  nai_nadifl = nai   
                  fcurrent()
                  e_pas = v + (ina+ik)/g_pas   // remember to add ica if needed

                  }
                }

              
                PERIOD_B = 1000/0.7/(2.32^((celsius-6)/10))      // Define period between stimuli
                PERIOD = PERIOD_B*0.2/5 
                countdown = 0         // Spike interval variable
                pulsecount = NPULSES        // Spike number variable
                burst_finished = 0


                t=0               // Set time variable (t) to zero
                dt = 0.025          // Time step in msec
                tstop = 40000
                stim.dur = tstop  

                spike_a=0
                spike_b=0
                spike_c=0
                no_spike_a = 0
                no_spike_a = 0
                no_spike_a = 0

                num_pulse=0
                num_spike_a=0
                num_spike_b=0
                num_spike_c=0

                while (t<tstop){                   // Simulation Loop starts here


                  stim.amp = 0           // Stimulation amplitude is set to zero

                  if ((t>=100) && (pulsecount > 0) &&(t<tstop)){      // After 100 msec, start stimulating

                    if ((countdown <= 0) && (countdown > -1)) stim.amp = 65     // Stimulate 1 ms pulse

                    if (countdown <= -1){   // done with this pulse             // End of 1 ms pulse
                      countdown = PERIOD                     // Reset interval variable to spike 
                      pulsecount -= 1            // Decrement count of pulses
                      num_pulse +=1

                      // reset the interval variable to bursting period
                      if(pulsecount==0){        
                        burst_finished = 1    
                        countdown=PERIOD_B * 0.8    
                        pulsecount=NPULSES
                      }

                    }
                  }

                  if((t>100)&&(t<101)){

                    a_initial = a.nai(0.9)
                    b_initial = b[1].nai(0.9)
                    c_initial = c[3].nai(0.9)
                  }

                  if ((t>=100)) countdown -= dt    // Decrement interval variable

                  if(t>50){
                      if(a.v(0.9)>-10){
                        if(no_spike_a == 1){
                          num_spike_a += 1
                          no_spike_a = 0                 
                        }
                      }else{
                          no_spike_a = 1
                      }
                      if(b[1].v(0.9)>-10){
                        if(no_spike_b == 1){
                          num_spike_b += 1
                          no_spike_b = 0
                        }
                      }else{
                        no_spike_b = 1
                      }
                      if(c[3].v(0.9)>-10){
                        if(no_spike_c == 1){
                          num_spike_c += 1
                          no_spike_c = 0
                        }
                      }else{
                        no_spike_c = 1
                      }
                  }

                  // check the conditions before the start of each burst, stop the simulation if condition is met

                  if(burst_finished == 1 && countdown < 0.1 && countdown > 0){

                    print "spikes:", num_pulse, num_spike_a, num_spike_b, num_spike_c
                    print "concentration:", a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9)

                    burst_finished = 0

                    // check for spike failure at the main axon, if spike fails, stop the simulation

                    if(num_spike_a >= num_pulse){

                      // check for spike failure at the primary branches, if spike fails, stop the simulation

                      if(num_spike_b >= num_pulse){

                        // check for spike failure at the secondary branches, if spike fails, stop the simulation

                        if(num_spike_c >= num_pulse){


                          // check for change in concentration if no spike failure, if change is small it means the sodium concentration has reached a steady state.

                          if(a.nai(0.9) <= a_initial + 0.05 && b[1].nai(0.9) <= b_initial + 0.05 && c[3].nai(0.9) <= c_initial +0.05 ){

                            tstop = t
                            fprint("3 %g %g %g", a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9))
                          }else{

                            if(a.nai(0.9) > a_initial){

                                a_initial = a.nai(0.9)
                            }
                            if(b[1].nai(0.9) > b_initial){

                                b_initial = b[1].nai(0.9)
                            }
                            if(c[3].nai(0.9) > c_initial){

                                c_initial = c[3].nai(0.9)
                            }
                          }

                        }else{

                          tstop = t
                          fprint("2 %g %g %g" , a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9))
                        }
                      }else{

                          tstop = t
                          fprint("1 %g %g %g" , a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9))
                      }
                    }else{

                        tstop = t
                        fprint("0 %g %g %g" , a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9))
                    }

                    // check for concentration decrease

                  }
                 fadvance()           // Advance simulation one time step     

                }

                // if the simulation reaches 40000ms without spike failure or steady state, it means the sodium potassium pump current has reached a steady state
                if(tstop == 40000){

                  fprint("5 %g %g %g" , a.nai(0.9), b[1].nai(0.9), c[3].nai(0.9))
                }

              }
            fprint("\n")
          } 
        }


      }
    }
  }

}

